<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"/>
	<link type="text/css" rel="stylesheet" href="shared/css/style.css"/>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({ TeX: { equationNumbers: {autoNumber: "all"} } });
</script>
<script type="text/javascript" src="shared/js/MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>

<div style="display:none">
<span class="math">\(\newcommand{\A}{\mat{A}}\)</span>
<span class="math">\(\newcommand{\B}{\mat{B}}\)</span>
<span class="math">\(\newcommand{\C}{\mat{C}}\)</span>
<span class="math">\(\newcommand{\D}{\mat{D}}\)</span>
<span class="math">\(\newcommand{\E}{\mat{E}}\)</span>
<span class="math">\(\newcommand{\F}{\mat{F}}\)</span>
<span class="math">\(\newcommand{\G}{\mat{G}}\)</span>
<span class="math">\(\newcommand{\I}{\mat{I}}\)</span>
<span class="math">\(\newcommand{\K}{\mat{K}}\)</span>
<span class="math">\(\newcommand{\L}{\mat{L}}\)</span>
<span class="math">\(\newcommand{\M}{\mat{M}}\)</span>
<span class="math">\(\newcommand{\N}{\mat{N}}\)</span>
<span class="math">\(\newcommand{\One}{\mathbf{1}}\)</span>
<span class="math">\(\newcommand{\P}{\mat{P}}\)</span>
<span class="math">\(\newcommand{\Q}{\mat{Q}}\)</span>
<span class="math">\(\newcommand{\Rot}{\mat{R}}\)</span>
<span class="math">\(\newcommand{\R}{\mathbb{R}}\)</span>
<span class="math">\(\newcommand{\S}{\mathcal{S}}\)</span>
<span class="math">\(\newcommand{\T}{\mat{T}}\)</span>
<span class="math">\(\newcommand{\U}{\mat{U}}\)</span>
<span class="math">\(\newcommand{\V}{\mat{V}}\)</span>
<span class="math">\(\newcommand{\W}{\mat{W}}\)</span>
<span class="math">\(\newcommand{\X}{\mat{X}}\)</span>
<span class="math">\(\newcommand{\Y}{\mat{Y}}\)</span>
<span class="math">\(\newcommand{\argmax}{\mathop{\text{argmax}}}\)</span>
<span class="math">\(\newcommand{\argmin}{\mathop{\text{argmin}}}\)</span>
<span class="math">\(\newcommand{\c}{\vec{c}}\)</span>
<span class="math">\(\newcommand{\d}{\vec{d}}\)</span>
<span class="math">\(\newcommand{\e}{\vec{e}}\)</span>
<span class="math">\(\newcommand{\f}{\vec{f}}\)</span>
<span class="math">\(\newcommand{\g}{\vec{g}}\)</span>
<span class="math">\(\newcommand{\mat}[1]{\mathbf{#1}}\)</span>
<span class="math">\(\newcommand{\min}{\mathop{\text{min}}}\)</span>
<span class="math">\(\newcommand{\n}{\vec{n}}\)</span>
<span class="math">\(\newcommand{\p}{\vec{p}}\)</span>
<span class="math">\(\newcommand{\transpose}{{\mathsf T}}\)</span>
<span class="math">\(\newcommand{\tr}[1]{\mathop{\text{tr}}{\left(#1\right)}}\)</span>
<span class="math">\(\newcommand{\t}{\vec{t}}\)</span>
<span class="math">\(\newcommand{\u}{\vec{u}}\)</span>
<span class="math">\(\newcommand{\vec}[1]{\mathbf{#1}}\)</span>
<span class="math">\(\newcommand{\x}{\vec{x}}\)</span>
<span class="math">\(\newcommand{\y}{\vec{y}}\)</span>
<span class="math">\(\newcommand{\z}{\vec{z}}\)</span>
<span class="math">\(\renewcommand{\v}{\vec{v}}\)</span>
</div>

<h1 id="geometryprocessing–deformation">Geometry Processing – Deformation</h1>

<blockquote>
<p><strong>To get started:</strong> Fork this repository then issue</p>

<pre><code>git clone --recursive http://github.com/[username]/geometry-processing-deformation.git
</code></pre>
</blockquote>

<h2 id="installationlayoutandcompilation">Installation, Layout, and Compilation</h2>

<p>See
<a href="http://github.com/alecjacobson/geometry-processing-introduction">introduction</a>.</p>

<h2 id="execution">Execution</h2>

<p>Once built, you can execute the assignment from inside the <code>build/</code> by running
on a given mesh:</p>

<pre><code>./deformation [path to mesh.obj]
</code></pre>

<p>When the mesh is blue, the system is in &#8220;place handles&#8221; mode. Click on the mesh
to select vertex locations for control point handles. After pressing space to switch to
deformation mode, drag the handles. Pressing <code>m</code> will switch between different
deformation methods.</p>

<figure>
<img src="images/knight-deformation.gif" alt="" />
</figure>

<h2 id="background">Background</h2>

<p>In this assignment we explore smooth deformation of an existing shape. <a href="https://en.wikipedia.org/wiki/Deformation_(mechanics)">Shape
deformation</a> has many
applications in geometry process; we will focus on interactive <strong><em>handle-based
deformation</em></strong>. In this setup, the user repositions a sparse set of points and the
goal is to propagate the transformation at these &#8220;handles&#8221; to the rest of the
shape. To be interactive we should aim for computing the new deformation of the
shape at around 30 <a href="https://en.wikipedia.org/wiki/Frame_rate">frames per
second</a>.</p>

<p>Shape deformation is the transformation from its <em>rest shape</em> to a
new/current/deformed shape. If the position of a point on some 3D rest shape
 given by <span class="math">\(\hat{\x} ∈ \R³\)</span> then we will write that the unknown position
on the deformed shape is given by <span class="math">\(\x ∈ \R³\)</span>. We can write this point&#8217;s
displacement vector as <span class="math">\(\x - \hat{\x} =: \d ∈ \R³\)</span>.</p>

<p>The propagation of the handles&#8217; deformation can be thought of in two
complementary ways:</p>

<ol>
<li>as a <a href="https://en.wikipedia.org/wiki/Multivariate_interpolation#Irregular_grid_.28scattered_data.29">scattered data
 interpolation</a>
 problem, where handles provide sparse samples of an unknown <a href="https://en.wikipedia.org/wiki/Displacement_field_(mechanics)">displacement
 field</a>, or</li>
<li>as a shape optimization problem, where we try to define a <em>new</em> shape that
 retains the details of the old shape but fulfills the handle constraints.</li>
</ol>

<p>In the following discussion we will take advantage of the ability to switch
between thinking of the unknowns as the positions of the deformed shape (<span class="math">\(\x\)</span>)
and displacements (<span class="math">\(\d\)</span>). These views are equivalent, but often one or the
other provides a better intuitive understanding.</p>

<h4 id="continuity">Continuity</h4>

<p>We will limit ourselves to <em>continuous</em> deformations of shapes. That is, the
shape will not tear, crack or change its topological features. </p>

<p>If we represent our shape discretely as a <a href="https://en.wikipedia.org/wiki/Triangle_mesh">triangle
mesh</a> (e.g., with <em>rest</em> vertices
in <span class="math">\(\hat{\V}
∈ \R^{n × 3}\)</span> and faces in <span class="math">\(F ∈ \{1,…,n\}^{m × 3}\)</span>, then we can <em>trivially</em>
ensure a continuous deformation by determining new vertex positions <span class="math">\(\V\)</span>. The
topology (connectivity) of the mesh (<span class="math">\(F\)</span>) will not change.</p>

<h4 id="genericdistortionminimization">Generic Distortion Minimization</h4>

<p>A rest surface <span class="math">\(\hat{S}\)</span>
<a href="https://en.wikipedia.org/wiki/Immersion_(mathematics)">immersed</a> in <span class="math">\(\R³\)</span> can
be described as a mapping <span class="math">\(\hat{\x}\)</span> from <em>some</em> 2D parameteric domain <span class="math">\(Ω\)</span>. For any
parameters <span class="math">\(u\)</span> and <span class="math">\(v\)</span>, <span class="math">\(\hat{\x}\)</span> describes the 3D position:</p>

<p><span class="math">\[
\hat{\x}(u,v) ∈ \R³.
\]</span></p>

<p>Similarly the deformed surface can be represented as a position function <span class="math">\(\x:
Ω → \R³\)</span>. The displacement vector field is thus a function taking the
difference: <span class="math">\(\d(u,v) = \x(u,v) - \hat{\x}(u,v)\)</span>.</p>

<p>For the handle-based deformation problem we would like to find a new surface
(defined by <span class="math">\(\x\)</span>) that:</p>

<ol>
<li>adds as little <em>distortion</em> as possible to the shape, and</li>
<li>satisfies the users constraints at selected handle positions.</li>
</ol>

<p>We can cast this as an energy optimization problem. Suppose we have
energy <a href="https://en.wikipedia.org/wiki/Functional_(mathematics)">functional</a>
<span class="math">\(E(\x)\)</span> that
measures the amount of distortion between the new shape (<span class="math">\(\x\)</span>) and the rest
shape <span class="math">\(\hat{x}\)</span>, then we could optimize for the best possible shape <span class="math">\(\x\)</span> by
minimizing <span class="math">\(E\)</span>:</p>

<p><span class="math">\[
\min_\x E(\x). 
\]</span></p>

<p>To ensure that the user&#8217;s <span class="math">\(k\)</span> handle points are interpolated we add the
constraints:</p>

<p><span class="math">\[
\text{ subject to } \x(u_i, v_i) = \g_i \ ∀ i = \{1, … , k\},
\]</span>
where <span class="math">\(\g_i\)</span> is the position of the $i$th control point handle.</p>

<p>While the constraints are straightforward, we have many choices for how to
formulate the energy function <span class="math">\(E\)</span>. A natural choice is to measure distortion in
an egalitarian way by integrating a <em>local</em> measure of distortion at all points
on the surface:</p>

<p><span class="math">\[
\min_\x ∫_Ω ‖ e(\x) ‖² \ dA \quad \text{ subject to } \x(u_i, v_i) = \g_i \ ∀ i = \{1, … , k\},
\]</span></p>

<p>where <span class="math">\(e\)</span> is a vector- or scalar- valued function measuring local (unsquared)
distortion. We will now consider different choices for <span class="math">\(e\)</span>.</p>

<h3 id="linearmethods">Linear Methods</h3>

<p>If we assume that the deformation between the rest shape given by <span class="math">\(\hat{\x}\)</span>
and the new shape given by <span class="math">\(\x\)</span> is <em>small</em> then we can measure the distortion
of the deformation in terms of the smoothness of the displacement field. This
simplest methods will integrate the magnitude of derivatives of the
displacement field (<span class="math">\(\d\)</span>): if the displacement field has large variations or
sudden changes then it is inducing a lot of distortion.</p>

<h4 id="gradient-basedenergy">Gradient-based energy</h4>

<p>Let us first consider minimizing the integral of squared variation of the
displacement field:</p>

<p><span class="math">\[
\min_\d ∫_Ω ‖ ∇\d ‖_F^2 \ dA \quad \text{ subject to } \d_i =
\g_i-\hat{\x}_i \ ∀ i = \{1, … , k\},
\]</span>
where
<span class="math">\(∇\d = \left(\begin{array}{ccc}
\frac{∂d^x}{∂u} & \frac{∂d^y}{∂u} & \frac{∂d^z}{∂u} \\
\frac{∂d^x}{∂v} & \frac{∂d^y}{∂v} & \frac{∂d^z}{∂v}
\end{array}\right)\)</span>
the <a href="https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant">Jacobian</a>
matrix of the displacement field <span class="math">\(\d\)</span> </p>

<blockquote>
<h5 id="deformationgradient">Deformation Gradient</h5>

<p>If <span class="math">\(\I ∈ \R^{3 × 3}\)</span> is the identity matrix, then the quantity <span class="math">\(\F := \I +
∇\d\)</span> is referred to as the <a href="https://en.wikipedia.org/wiki/Finite_strain_theory#Deformation_gradient_tensor">deformation
gradient</a>
in the <a href="https://en.wikipedia.org/wiki/Continuum_mechanics">mechanics</a>
community.</p>
</blockquote>

<p>This is simply the familiar <a href="https://en.wikipedia.org/wiki/Dirichlet's_energy">Dirichlet
energy</a> applied to each
coordinate function of the displacement field <em>independently</em>.</p>

<p>We can discretize this over our triangle mesh surface the same way we have in
smoothing and parameterization assignments:</p>

<p><span class="math">\[
\min_{\D} \tr{\D^\transpose \L \D} \quad \text{subject to } \D_\text{handles} =
\g_\text{handles} - \hat{\V}_\text{handles},
\]</span>
where the rows of <span class="math">\(\g_\text{handles} ∈ \R^{k × 3}\)</span> contains the new positions
of the <span class="math">\(k\)</span> control point handles.</p>

<p>While easy to implement, this method suffers from a couple immediate problems:</p>

<ol>
<li>it is not smooth at constraints, and</li>
<li>then <em>influence</em> of handles dies off too quickly.</li>
</ol>

<figure>
<img src="images/bump-k-harmonic.jpg" alt="Two regions of selected points (purple) are constrained. The gradient-based
energy produces a continuous displacement but is not smooth at the inner
constrained points (sharp crease). The Laplacian-based energy produces a
displacement with continuous positions and
derivatives." />
<figcaption>Two regions of selected points (purple) are constrained. The gradient-based
energy produces a <em>continuous</em> displacement but is not <em>smooth</em> at the inner
constrained points (sharp crease). The Laplacian-based energy produces a
displacement with continuous positions and
derivatives.</figcaption>
</figure>

<p>By minimizing the Dirichlet energy, each coordinate of &#8220;displacement field&#8221; is
a <a href="https://en.wikipedia.org/wiki/Harmonic_function">harmonic function</a>.
Intuitively (however abstractly) we can think of each function as <em>diffusing</em>
the user&#8217;s constraints as if they were
<a href="https://en.wikipedia.org/wiki/Heat_equation">heat</a> values. As such, each
function diffuses quickly to an average, slowly varying value over most of the
domain. As a displacement field a constant value for each coordinate function
would mean a translation: most of the shape is simply translated.</p>

<figure>
<img src="images/bunny-harmonic.gif" alt="" />
</figure>

<p>The gradient operator (<span class="math">\(∇\)</span>) is a <a href="https://en.wikipedia.org/wiki/Linear_map"><em>linear</em>
operator</a>. We can alternatively view
our minimization above in terms of the unknown positions <span class="math">\(\x\)</span>:</p>

<p><span class="math">\[
\min_\d ∫_Ω ‖ ∇\d ‖_F^2 \ dA ⇒ 
\min_\x ∫_Ω ‖ ∇(\x - \hat{\x}) ‖_F^2 \ dA ⇒ 
\min_\x ∫_Ω ‖ \underbrace{∇\x}_\text{after} -
\underbrace{∇\hat{\x}}_\text{before} ‖_F^2 \ dA.
\]</span>
If we think of the gradient of the position function <span class="math">\(∇\x\)</span> (with respect to the
underlying parameterization <span class="math">\(u,v\)</span>) as a local geometric <a href="https://en.wikipedia.org/wiki/Feature_(computer_vision)">feature
descriptor</a> then this
energy can be re-understood as measuring the difference in this feature before
and after the deformation. This is very sensible as we are trying to measure
distortion. We would expect that a low-distortion deformation would correspond
with a small change to local features.</p>

<p>Unfortunately, the gradient of the position function <span class="math">\(\x\)</span> is a <em>poor</em>,
first-order local feature.</p>

<h4 id="laplacian-basedenergy">Laplacian-based energy</h4>

<p>If we model distortion as the change in a local feature descriptor, then a
natural local and <em>relative</em> descriptor would be one that compared the position
of some point on the shape to the average of its local neighborhood. We have
studied an operator that computes this in the smoothing assignment. The
<a href="https://en.wikipedia.org/wiki/Laplace_operator">Laplace(-Beltrami) operator</a>
can be derived as taking exactly the difference of a functions value at a point
and the average (i.e., <a href="https://en.wikipedia.org/wiki/Centroid">centroid</a>) of
an infinitesimal region around that point:</p>

<p><span class="math">\[
∆ f(\x) = \lim_{|B(\x)| → 0} \frac{1}{|B(\x))|} ∫_{B(\x)} f(\z) \;d\z - f(\x)
\]</span></p>

<p>(see, e.g., &#8220;Differential coordinates for local mesh morphing and deformation&#8221;
[Alexa et al. 2003] and expanded upon in &#8220;Laplacian Surface Editing&#8221;
[Sorkine et al. 2004]).</p>

<p>When applied to the embedding function <span class="math">\(\x\)</span> the Laplace operator computes the
difference in <em>position</em> between a point and its local neighborhood. This
<em>vector</em> points in the
<a href="https://en.wikipedia.org/wiki/Normal_(geometry)">normal</a> direction and its
magnitude corresponds inversely with <a href="https://en.wikipedia.org/wiki/Mean_curvature">how flat the surface is
locally</a>.</p>

<p>Let&#8217;s replace the gradient feature above with this <em>second-order</em> feature
descriptor and massage our optimization problem back in terms of
displacements:</p>

<p><span class="math">\[
\min_\x ∫_Ω ‖ \underbrace{∆\x}_\text{after} -
\underbrace{∆\hat{\x}}_\text{before} ‖^2 \ dA ⇒
\min_\x ∫_Ω ‖ ∆(\x - \hat{\x}) ‖^2 \ dA ⇒ 
\min_\d ∫_Ω ‖ ∆\d ‖^2 \ dA.
\]</span></p>

<p>Just as we can show that harmonic functions (<span class="math">\(∆\d = 0\)</span>) minimize the Dirichlet
energy, we can use <a href="https://en.wikipedia.org/wiki/Calculus_of_variations">calculus of
variations</a> apply
<a href="https://en.wikipedia.org/wiki/Green's_identities">Green&#8217;s identity</a> <em>twice</em> to
show that minimizers of the squared-Laplacian energy are _bi-_harmonic
functions (<span class="math">\(∆∆\d = 0\)</span> or <span class="math">\(∆²\d = 0\)</span>). Obviously all harmonic functions are also
biharmonic functions. This implies that the space of biharmonic functions is
strictly <em>larger</em>. In particular, this will allow use to ensure continuity of
first derivatives across constrained values at handles.</p>

<figure>
<img src="images/bunny-biharmonic.gif" alt="" />
</figure>

<p>The fact that each coordinate of the displacement field <span class="math">\(\d\)</span> will be a
bi-harmonic function is not so elucidating, but by minimizing the
squared-Laplacian energy integrated over the domain, we can say that it is
as-<em>harmonic</em>-as-possible. Harmonic functions include constant functions (i.e.,
translations) but also any displacement that <em>bends</em> in one direction by an
equal and opposite amount as it bends in the other direction: <span class="math">\(∆\d = 0 → ∂\d/∂u
+ ∂\d/∂v = 0 → ∂\d/∂u = -∂\d/∂v\)</span>.</p>

<p>To discretize this energy we can make use of our discrete Laplacian operator
<span class="math">\(\L\)</span>. This matrix computes the locally <em>integrated</em> Laplacian of a given
function specified by per-vertex values <span class="math">\(\f\)</span>. Now we would like to integrate
the square of the <em>point-wise</em> Laplacian. We can approximate the point-wise
Laplacian by the local <a href="https://en.wikipedia.org/wiki/Mean_of_a_function">integral
average</a> of the Laplacian
<span class="math">\(\M^{-1}\L \f\)</span>. Integrating this over the mesh we have our complete approximate
of the energy:</p>

<p><span class="math">\[
\begin{align}
∫_Ω ‖∆\d‖² \;dA &≈ \tr{ \D^\transpose \L^\transpose \M^{-\transpose} \M \M^{-1} \L
\D}\\
&= \tr{ \D^\transpose \underbrace{\L^\transpose \M^{-1} \L}_{\Q} \D },
\end{align}
\]</span>
where <span class="math">\(\M ∈ \R^{n × n}\)</span> is the mass-matrix for the given mesh and <span class="math">\(\Q ∈
\R^{n×n}\)</span> can be thought of as the bi-Laplacian matrix.</p>

<blockquote>
<h4 id="k-harmonic"><span class="math">\(k\)</span>-harmonic</h4>

<p>The logical continuation of harmonic and biharmonic deformation is to consider
<em>triharmonic</em> (<span class="math">\(∆³\d = 0\)</span>) and <em>tetraharmonic</em> (<span class="math">\(∆⁴\d = 0\)</span>) and so on. It&#8217;s
straightforward to implement these, though there are diminishing returns and
increasing costs.</p>
</blockquote>

<h5 id="precomputation">Precomputation</h5>

<p>With out loss of generality, assume that the rows of the unknown displacements
<span class="math">\(\D\)</span> have been sorted so that displacements corresponding to handle vertices
are in the bottom part:</p>

<p><span class="math">\[
\D = \left(\begin{array}{c}
\D_\text{u} \\
\D_\text{h}
\end{array}
\right)
\]</span></p>

<p>Since the displacements at handles are <em>known</em> before the optimization, we can
separate the knowns and unknowns in the energy:</p>

<p><span class="math">\[
\min_{\D_\text{u}}
\tr{(\D_\text{u}^\transpose \ \D_\text{h}^\transpose)
\left(\begin{array}{cc}
\Q_\text{u,u} & \Q_\text{u,h} \\
\Q_\text{h,u} & \Q_\text{h,h} 
\end{array}\right)
\left(\begin{array}{c}
  \D_\text{u} \\
  \D_\text{h}
\end{array}
\right)} \\
\min_{\D_\text{u}}
\tr{\D_\text{u}^\transpose \Q_\text{u,u} \D_\text{u} +
2 \D_\text{u}^\transpose \Q_\text{u,h} \D_\text{h} + 
\underbrace{\D_\text{h}^\transpose \Q_\text{h,h}
\D_\text{h}}_\text{constant}} \\
\min_{\D_\text{u}} 
\tr{
\D_\text{u}^\transpose \Q_\text{u,u} \D_\text{u} +
2 \D_\text{u}^\transpose \Q_\text{u,h} \D_\text{h}}
\]</span>
where <span class="math">\(\Q_\text{u,u} ∈ \R^{(n-k) × (n-k)}\)</span> is the quadratic coefficients matrix
corresponding to the unknown displacements.</p>

<p>This quadratic optimization problem may solved by setting all partial
derivatives with respect to degrees of freedom in <span class="math">\(\D_\text{u}\)</span> to zero:</p>

<p><span class="math">\[
2 \Q_\text{u,u} \D_\text{u} + 2 \Q_\text{u,h} \D_\text{h}
= 0 → \D_\text{u} = \Q_\text{u,u}^{-1} \Q_\text{u,h} \D_\text{h}
\]</span></p>

<p>If we don&#8217;t change <em>which</em> vertices are handles, but only change the positions
of the selected handles, then only <span class="math">\(\D_\text{h}\)</span> changes above. In particular,
the matrix <span class="math">\(\Q_\text{u,u}\)</span> is unchanged. Therefore, we can
<a href="https://en.wikipedia.org/wiki/Cholesky_decomposition">prefactorize</a> it so that
<em>applying its inverse</em> is fast (<code>igl::min_quad_with_fixed</code> does this for you).</p>

<blockquote>
<p>Actually the entire term <span class="math">\(\Q_\text{u,u}^{-1} \Q_\text{u,h} =: \W ∈ \R^{(n-k)
× k}\)</span> does not change. The columns of <span class="math">\(\W\)</span> reveal how unknown displacements
respond to each handle point&#8217;s displacement (see also &#8220;An intuitive framework
for real-time freeform modeling&#8221; [Botsch &amp; Kobbelt 2004]). This provides a
gateway to the relationship with linear blend skinning and automatic
(biharmonic) weighting functions (see &#8220;Bounded Biharmonic Weights for
Real-Time Deformation&#8221; [Jacobson et al. 2011]).</p>
</blockquote>

<h5 id="troubleinparadise">Trouble in paradise</h5>

<p>Biharmonic displacements work well for small deformations and deformations that
do not imply a large rotation. However, the Laplacian of the position function
<span class="math">\(∆\x\)</span> as a feature descriptor is <em>not</em> rotation invariant. This problem is true
for all linear differential features including the gradient of the embedding
function <span class="math">\(∇\x\)</span> considered above (see &#8220;On linear variational surface deformation
methods&#8221; [Botsch &amp; Sorkine 2008]).</p>

<figure>
<img src="images/knight-biharmonic-large-rotation.gif" alt="" />
</figure>

<p>This means that if the user transforms all of the handle locations by a rigid
transformation <span class="math">\(\T\)</span> these energies will <em>not</em> measure zero for a displacement
equivalent to applying the rigid transformation <span class="math">\(\T\)</span> to the entire shape. We
would like <em>global</em> rotation invariance, but we would also like this property
to apply <em>locally</em> so that parts of the shape can easily rotate.</p>

<h3 id="as-rigid-as-possible">As-rigid-as-possible</h3>

<p>In the scenario where each handle
<span class="math">\(i\)</span> are perfectly transformed by a <a href="https://en.wikipedia.org/wiki/Rigid_transformation">rigid
transformation</a> <span class="math">\(\x_i =
\Rot \hat{\x}_i + \t\)</span>, where <span class="math">\(\Rot ∈ SO(3) ⊂ \R^{3×3}\)</span> is a rotation matrix and
<span class="math">\(\t∈\R^3\)</span> is a translation vector. If an
<a href="https://en.wikipedia.org/wiki/Oracle">oracle</a> could only tell us this
particular rigid transformation then we could repair
the gradient-based energy above by pre-rotating the rest shape by this
transformation:</p>

<p><span class="math">\[
\begin{align}
∫_Ω ‖ ∇ \x - ∇(\Rot \hat{\x} + \t) ‖² \;dA 
  &= ∫_Ω ‖ ∇ \x - ∇(\Rot \hat{\x}) - ∇\t‖² \;dA \\
  &= ∫_Ω ‖ ∇ \x - \Rot ∇\hat{\x} ‖² \;dA,
\end{align}
\]</span></p>

<p>where the translation vector <span class="math">\(\t\)</span> falls out because a translation has constant
gradient.</p>

<p>We do not know the rotation <span class="math">\(\Rot\)</span> ahead of time, but we could be as generous
as possible and use the &#8220;best&#8221; rotation <span class="math">\(\Rot ← \argmin_\Rot ∫_Ω ‖ ∇\x -  \Rot
∇\hat{\x} ‖² \;dA\)</span>:</p>

<p><span class="math">\[
∫_Ω \left\|∇\x - \left( \argmin_\Rot ∫_Ω ‖ ∇\x -  \Rot ∇\hat{\x} ‖² \;dA \right)∇\hat{\x}\right\|² \;dA.
\]</span></p>

<p>If we treat <span class="math">\(\Rot\)</span> as a degree of freedom along with the unknown positions
<span class="math">\(\x\)</span>, we can unify this into an optimization over <span class="math">\(\x\)</span> and <span class="math">\(\Rot\)</span>:</p>

<p><span class="math">\[
\min_{\x,\Rot∈SO(3)} ∫_Ω \left\|∇\x - \Rot ∇\hat{\x}\right\|² \;dA.
\]</span></p>

<p>Optimizing this energy will ensure <em>global</em> rotation invariance. To ensure
<em>local</em> rotation invariance, we can replace <span class="math">\(\Rot ∈ SO(3)\)</span> with a spatially
varying <em>function</em> <span class="math">\(\Rot : Ω → SO(3)\)</span> that outputs a &#8220;best&#8221; rotation for any
point on the shape (see &#8220;A simple geometric model for elastic deformations&#8221;
[Chao et al. 2010]). In this way, the optimal rotation will be locally rigid
everywhere, or <em>as-rigid-as-possible</em> (ARAP).</p>

<figure>
<img src="images/knight-arap-large-rotation.gif" alt="" />
</figure>

<blockquote>
<p>For embedded solid shapes, we can take the rest shape given by <span class="math">\(\hat{\x}\)</span> as
the parameterization <span class="math">\(Ω\)</span>, so that <span class="math">\(∇\hat{\x} = \I\)</span>. This allows us to rewrite
the as-rigid-as-possible energy as the square of the difference between the
<a href="#deformationgradient">deformation gradient</a> and the closest rotation:</p>

<p><span class="math">\[
∫_Ω \left\|∇\x - \Rot ∇\hat{\x}\right\|² \;dA \\
∫_Ω \left\|(∇\x + \I - \I) - \Rot \I \right\|² \;dA \\
∫_Ω \left\|(\I + ∇\x - ∇\hat{x}) - \Rot \right\|² \;dA \\
∫_Ω \left\|(\I + ∇\d) - \Rot \right\|² \;dA \\
∫_Ω \left\|\F - \Rot \right\|² \;dA \\
\]</span></p>

<p>This form provides a bridge between the as-rigid-as-possible energy common in
geometry processing to <em>corotated linear elasticity</em> used in
mechanics/physically-based simulation (made explicit in &#8220;A simple geometric
model for elastic deformations&#8221; [Chao et al. 2010]). See Section 3.4 of &#8220;FEM
Simulation of 3D Deformable Solids&#8221; [Sifakis 2012] for a graphics-mechanics
perspective.</p>
</blockquote>

<h4 id="discreteas-rigid-as-possibleenergy">Discrete as-rigid-as-possible energy</h4>

<p>For a triangle mesh with displacing vertices, the gradient of the embedding
function is constant inside each triangle. In this way we can write the raw
gradient energy above as a double sum over all half-edges <span class="math">\(ij\)</span> of all faces <span class="math">\(f\)</span>
in the mesh:</p>

<p><span class="math">\[
½ ∫_Ω ‖ ∇ \x - ∇\hat{\x}‖² \;dA = ½ ∑\limits_{f ∈ F} ∑\limits_{ ij ∈ f} c_{ij} ‖
(\v_i-\v_j) - (\hat{\v}_i-\hat{\v}_j)‖²,
\]</span>
where <span class="math">\(c_{ij}\)</span> is cotangent of the angle opposite half-edge <span class="math">\(ij\)</span>.</p>

<p>To inject localized best fit rotations, we will assign an unknown rotation
matrix <span class="math">\(\Rot_k\)</span> to each vertex <span class="math">\(k\)</span> of the mesh and accounts for a third of the
energy integrated over incident triangles:
<span class="math">\[
½ ∫_Ω ‖ ∇ \x - \Rot ∇\hat{\x}‖² \;dA = 
⅙ ∑\limits_{k=1}^n ∑\limits_{ ij ∈ F(k)} 
c_{ij} ‖ (\v_i-\v_j) - \Rot_k (\hat{\v}_i-\hat{\v}_j)‖²,
\]</span>
where <span class="math">\(F(k)\)</span> is the set of all faces incident on the <span class="math">\(k\)</span>-th vertex.</p>

<h4 id="optimization">Optimization</h4>

<p>The simplest method for optimizing the ARAP energy is by alternating between</p>

<ol>
<li>finding the optimal rotations <span class="math">\(\Rot_k\)</span> assuming the vertex positions <span class="math">\(\V\)</span> are
 fixed, and</li>
<li>finding the optimal vertex positions <span class="math">\(\V\)</span> assuming all rotations <span class="math">\(\Rot_k\)</span> are
 fixed.</li>
</ol>

<p>Each rotation <span class="math">\(\Rot_k\)</span> only affects the local energy and doesn&#8217;t interact with
the <em>other</em> rotations. So each can be optimized <em>locally</em>. In contrast, the
mesh vertex positions <span class="math">\(\V\)</span> depend on each other requiring a <em>global</em> solve. In
the geometry processing literature, this is known as a local-global
optimization (see &#8220;As-rigid-as-possible surface modeling&#8221; [Sorkine &amp; Alexa
2007]). It is also known as &#8220;alternating block coordinate descent&#8221; because we
have separated the variables into disjoint sets (<span class="math">\(\V,\Rot_1,…,\Rot_n\)</span>) and taking
the optimal descent direction for each independently.</p>

<p>Observing the discrete energy above we can see that the energy is quadratic in
<span class="math">\(\V\)</span> and quadratic in each <span class="math">\(\Rot_k\)</span>. Let&#8217;s start by separating the terms that are
quadratic and linear in <span class="math">\(\V\)</span>:</p>

<p><span class="math">\[
⅙ \underbrace{∑\limits_{k=1}^n ∑\limits_{ ij ∈ F(k)}  c_{ij} (\v_i-\v_j)^\transpose(\v_i-\v_j)}_\text{quadratic}
+
⅙ \underbrace{∑\limits_{k=1}^n ∑\limits_{ ij ∈ F(k)}  c_{ij} (\v_i-\v_j)^\transpose \Rot_k (\hat{\v}_i-\hat{\v}_j)}_\text{linear}
\]</span></p>

<p>if we stack the rotation matrices <span class="math">\(\Rot_k\)</span> into large matrix <span class="math">\(\Rot ∈ \R^{3n ×
3}\)</span> then we can write this energy in matrix form as:</p>

<p><span class="math">\[
\tr{ \V^\transpose \L \V } + \tr{ \V^\transpose \K \Rot },
\]</span>
where <span class="math">\(\L ∈ \R^{n × n}\)</span> is the familiar cotangent discrete Laplacian matrix and
<span class="math">\(\K ∈ \R^{n × 3n}\)</span> sparse matrix containing cotangents multiplied against
differences across edges in the rest mesh (e.g., <span class="math">\(\hat{\v}_i - \hat{\v}_j\)</span>).</p>

<h5 id="localstep">Local step</h5>

<p>Minimizing this energy with respect <span class="math">\(\R\)</span> corresponds to minimizing:</p>

<p><span class="math">\[
\tr{ \underbrace{\V^\transpose \K}_{\C^\transpose} \Rot },
\]</span>
where <span class="math">\(\C ∈ \R^{3n × 3}\)</span> stacks weighted covariance matrices <span class="math">\(\C_k ∈ \R^{3 ×
3}\)</span> for each region <em>covered</em> by the corresponding rotation <span class="math">\(\Rot_k\)</span>. We have
seen this problem before in the registration assignment. For each <span class="math">\(\C_k\)</span>,
<span class="math">\(\Rot_k\)</span> will be the closest rotation matrix solved via <a href="https://en.wikipedia.org/wiki/Singular_value_decomposition">singular value
decomposition</a>.</p>

<h5 id="globalstep">Global step</h5>

<p>Minimizing the energy above with respect to <span class="math">\(\V\)</span> corresponds to solving a
Dirichlet energy-like minimization problem:</p>

<p><span class="math">\[
\min_\V \tr{ \V^\transpose \L \V } + \tr{ \V^\transpose \B }
\]</span></p>

<p>where <span class="math">\(\K \Rot =: \B ∈ \R^{n × 3}\)</span> is a matrix of rotated vertex gradients.
Adding the handle constraints to the corresponding rows of <span class="math">\(\V\)</span> this is easily
minimized by setting all partial derivatives with respect to the unknowns in
<span class="math">\(\V\)</span> equal to zero (as in the linear methods above).</p>

<h5 id="implementation">Implementation</h5>

<p>In order to facilitate interactive deformation we would like our local and
global iterations to be computed as quickly as possible. Since the quadratic
form in the global step is the <em>same</em> regardless of the current rotations or
current handle positions, we can
<a href="https://en.wikipedia.org/wiki/Cholesky_decomposition">prefactorize</a> it (again,
as above). The matrix <span class="math">\(\K\)</span> also does not depend on the rotations, current
positions or handle positions, so we can pre-build this matrix. This way
computing <span class="math">\(\C\)</span> and <span class="math">\(\B\)</span> is a simple matrix-matrix multiplication.</p>

<blockquote>
<p><strong>Note:</strong> When constructing <span class="math">\(\K\)</span> it&#8217;s easiest to iterate over <em>all</em>
half-edges in the mesh (by iterating over all faces and then each of the
three edges). Each half-edge <span class="math">\(ij\)</span> <em>contributes</em> terms tying <span class="math">\(\v_i,\v_j\)</span> to
<em>each</em> of the (three) rotations <span class="math">\(\Rot_k\)</span> that apply against their difference
(see &#8220;Fast Automatic Skinning Transformations&#8221; [Jacobson et al. 2012]).</p>
</blockquote>

<h5 id="stilltroubleinparadise">Still trouble in paradise</h5>

<figure>
<img src="images/knight-arap-high-vs-low-resolution.gif" alt="" />
</figure>

<p>The as-rigid-as-possible deformation method for surfaces described above has a
number of remaining problems:</p>

<ol>
<li>like its gradient-based energy ancestor the deformation is not smooth at
 constraints;</li>
<li>the energy punishes <em>bending</em> of the surface&#8211;which is good&#8211;but does so in
 a way that diminishes as the mesh becomes higher and higher resolution, in
 otherwords, the discrete energy is mesh-resolution dependent; and</li>
<li>the energy is biased by the original combinatorics of the mesh (even in
 flat regions).</li>
</ol>

<h2 id="tasks">Tasks</h2>

<h3 id="blacklist">Blacklist</h3>

<ul>
<li><code>igl::arap</code></li>
<li><code>igl::arap_linear_block</code></li>
<li><code>igl::covariance_scatter_matrix</code></li>
<li><code>igl::harmonic</code></li>
</ul>

<h3 id="whitelist">Whitelist</h3>

<ul>
<li><code>igl::polar_svd3x3</code> (or your previous assignment&#8217;s <code>closest_rotation</code>)</li>
<li><code>igl::min_quad_with_fixed</code></li>
<li><code>igl::cotmatrix_entries</code></li>
<li><code>igl::cotmatrix</code> (or your previous implementation)</li>
<li><code>igl::massmatrix</code> (or your previous implementation)</li>
</ul>

<h3 id="srcbiharmonic_precompute.cpp"><code>src/biharmonic_precompute.cpp</code></h3>

<p>Precompute data needed to efficiently solve for a biharmonic deformation given
a mesh with vertices <code>V</code> and faces <code>F</code> and a list of selected vertices as
indices <code>b</code> into <code>V</code>. The output should be a prefacorized system using the
<code>data</code> struct employed by <code>igl::min_quad_with_fixed</code>.</p>

<h3 id="srcbiharmonic_solve.cpp"><code>src/biharmonic_solve.cpp</code></h3>

<p>Given precomputation <code>data</code> and a list of handle <em>displacements</em> determine
<em>displacements</em> for all vertices in the mesh.</p>

<h3 id="srcarap_precompute.cpp"><code>src/arap_precompute.cpp</code></h3>

<p>Precompute data needed to efficiently conduct local-global iterations for an
arap deformation. This includes the <code>data</code> struct employed by
<code>igl::min_quad_with_fixed</code> to solve the global step&quot; and constructing the
bi-linear form <code>K</code> that mixes rotation degrees of freedom with unknown
positions for preparing the covariance matrices of the local step and the
linear term of the global step.</p>

<h3 id="srcarap_single_iteration.cpp"><code>src/arap_single_iteration.cpp</code></h3>

<p>Given precomputed data (<code>data</code> and <code>K</code>), handle <em>positions</em> <code>bc</code> and current
positions of all vertices <code>U</code>, conduct a <em>single</em> iteration of the local-global
solver for minimizing the as-rigid-as-possible energy. Output the <em>positions</em>
of all vertices of the mesh (by overwriting <code>U</code>).</p>

</body>
</html>
